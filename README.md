# Instruction-set-architecture-simulator
This GitHub project represents the implementation of a simulation of a custom instruction set architecture in the Java programming language. The simulation functions as an interpreter, and the source assembly code can be loaded from a file. This simulation enables the execution of basic arithmetic operations (ADD, SUB, MUL, DIV), basic bitwise logical operations (AND, OR, NOT, XOR), instructions for moving data between registers (MOV), instructions for inputting data from standard input and outputting data to standard output. Additionally, simple single-step debugging support has been implemented, allowing for the execution and viewing of the values of all registers and specified memory addresses at breakpoints in the assembly code during execution. In this mode, it is possible to transition to the next instruction (NEXT or STEP console commands) and transition to the next breakpoint (CONTINUE).

The memory of the simulated machine (guest) has a 64-bit address space, and direct and indirect addressing are supported. The contents of each memory address are 1 byte in length, and access to all addresses in the address space, including read and write operations, is possible using the appropriate instructions (MOV or LOAD/STORE).

Instructions necessary for unconditional and conditional branching (JMP, CMP, JE, JNE, JGE, JL) have been implemented. Assembly instructions can be translated into guest machine code (bytecode) and stored in the guest's address space, and instructions are executed from the guest's memory. The program counter (instruction pointer) is defined as a register used to track the current executed instruction.

The project also includes an example of guest assembly code that is self-modifying. After being translated into guest machine code, the modified part of the code is executed both before and after the relevant modification.
